# 渐进阅读（Incremental Reading）优化路线（可执行方案）

> 目标：把当前插件的 Topic/Extract 机制升级为更贴近 SuperMemo 的“漏斗式提纯”工作流：**Topic → Extract → Item（Cloze/Q&A）**，并让调度真正服务于“在有限时间内优先处理高价值信息”。  
> 备注：本文已按当前实现同步（`ir.priority` 为 0-100 单一真相；`#card.priority` 为 Number 镜像字段，仅用于展示/筛选）。

## 0. 背景：当前实现（与代码对应）

### 0.1 卡片类型与入口

- Topic：`#card.type=topic`（通过 `src/srs/topicCardCreator.ts` 创建）
- Extract：`#card.type=extracts`
  - 方式 A：选中文本执行摘录（`src/srs/extractUtils.ts`）
  - 方式 B：Topic 下创建子块自动标记（`src/srs/incrementalReadingAutoMark.ts`，开关由 `src/srs/settings/incrementalReadingSettingsSchema.ts` 控制）

### 0.2 IR 状态字段（Block Properties）

实现位于 `src/srs/incrementalReadingStorage.ts`，现有字段：

- `ir.priority`: number（0-100，数值越高越优先；唯一真相）
- `ir.lastRead`: Date | null
- `ir.readCount`: number
- `ir.due`: Date
- `ir.intervalDays`: number（当前间隔天数，用于下次 due）
- `ir.postponeCount`: number（累计推后次数：手动推后 + 溢出推后）
- `ir.stage`: string（漏斗阶段）
- `ir.lastAction`: string（最近一次动作）
- `ir.position`: number | null（Topic 队列位置，辅助顺序）
- `ir.resumeBlockId`: DbId | null（ir_record 记录进度，`src/srs/registry/commands.ts`）

### 0.3 调度与队列（今天该推送谁）

- 到期判定按“自然日 00:00”边界：`src/srs/incrementalReadingCollector.ts#collectIRCardsFromBlocks`
- 下一次到期：基础间隔由 `ir.priority(0-100)` + cardType 计算（`src/srs/incrementalReadingScheduler.ts`），实际写回由 `src/srs/incrementalReadingStorage.ts` 统一负责（含分散抖动与新 Extract 的兄弟排队延迟）
- 队列构建：`buildIRQueue`（`src/srs/incrementalReadingCollector.ts`）
  - Topic：按 `priority` 降序，其次 `due`，再按 `position`
  - Extract：按 `due` 升序，其次 `priority` 降序
  - `dailyLimit` 场景下：逾期 Extract 优先（先入队），其余再按 `topicQuotaPercent` 混排
  - 溢出推后（按钮触发）：`deferIROverflow` → `deferOverflowCards`（按优先级推后，并写回 `due/intervalDays/postponeCount/lastAction`；打开面板只展示，不自动改排期）

补充：排期与推送的详细记录与调试清单见 `模块文档/记忆排期推送.md`。

### 0.4 会话动作（你对卡做了什么）

UI：`src/components/IncrementalReadingSessionDemo.tsx`  
动作实现：`src/srs/incrementalReadingStorage.ts` + `src/srs/irSessionActions.ts`

- 已读：更新 `lastRead/readCount/due`（`markAsRead`）
- 靠前/靠后：Topic/Extract 统一调整 `ir.priority`（默认步长 ±10，并已读）
- 读完：移除 `#card` 并清理 `srs.*` + `ir.*`（`completeIRCard`）
- 跳过：仅从本次队列移除（不写回状态）

## 1. 目标与核心原则（从 SuperMemo “漏斗模型”落地到插件）

### 1.1 漏斗：Topic → Extract → Item（Cloze/Q&A）

1) 粗读（Import & Preview）
- 对象：Topic
- 目标：快速判断“值不值得进漏斗”
- 允许结果（必须三选一）：
  - 丢弃：无价值 → 删除 / 读完移出
  - 推后：太难/缺前置 → Postpone（明确推迟）
  - 提取：有价值段落 → 做 Extract

2) 提取与精炼（Extracting）
- 对象：Extract
- 目标：把信息压缩到“最小信息原则”（一次只记一个点）
- 允许结果（必须三选一）：
  - 精炼：改写/拆分/缩短（必要时继续拆分为更小 Extract）
  - 转化：信息“终身需要记住”且“已完全理解” → 生成 Item（Cloze/Q&A）
  - 丢弃/推后：不理解就不记忆；不合适就删；需要前置就推后

3) 主动回忆（Item）
- 对象：SRS 卡（Cloze/Q&A）
- 目标：进入遗忘曲线复习（现有 SRS 系统）
- 原则：Item 的数量与质量 > 覆盖率；宁可少而精，不要把大段文字塞进 SRS

### 1.2 会话目标：时间盒 + 高价值优先

- 每次会话只承诺一个目标：**在固定时间内（建议 15–30 分钟）推进漏斗**。
- 时间到即停，不追求“读完文章”；让调度决定下一次出现。
- “One memory, one action”：看到一张卡必须做一个动作（读/改/删/推后/提取/转化），避免“盯着看然后跳过”。

## 2. 现状与建议的关键差距（按影响排序）

### 2.1 Topic 会“永远频繁出现”（缺少间隔增长）

现状：Topic 的间隔完全由 `ir.priority` 固定映射，`readCount` 不影响间隔。  
风险：高优先级 Topic 可能长期高频出现，即使你并没有推进任何内容，也会持续占用配额。

### 2.2 Extract 的优先级在队列排序里可能失真

已解决：Extract 的调度/排序统一使用 `ir.priority`；`#card.priority` 仅作为镜像字段展示，不参与逻辑。

### 2.3 “跳过”不写回状态，容易违反 One-action 原则

现状：跳过只是临时移出本次队列，不影响 `due/priority/position`。  
后果：用户可以无限跳过，形成“看过但没处理”的隐性积压，调度无法学习。

### 2.4 溢出推后（Auto-postpone）相关的问题与修正

现状（已修正）：溢出推后改为“明确按钮触发”，打开面板只展示，不会在查看时自动改排期。  
建议方向：溢出推后应“优先推迟低优先级”，并把推迟体现为更合理的 `due`（不仅仅明天）。

## 3. 优化设计：把“漏斗原则”映射到当前插件结构

本节给出“最小可实现”的改造方案：尽量复用现有 `ir.*` 存储与会话 UI，只补关键字段与规则。

### 3.1 数据模型：补齐让调度能学习的字段

建议在 `ir.*` 新增（并由 `ensureIRState` 迁移补齐）：

1) `ir.intervalDays: number`
- 含义：当前间隔（天，可为小数），用于计算下一次 `due`
- 目标：让 Topic/Extract 的间隔随推进而增长（对应 SuperMemo 的 A-Factor 思路）

2) `ir.postponeCount: number`
- 含义：累计被推后次数（手动推后 + 溢出推后）
- 用途：做“自动老化/降权”、以及 backlog 的诊断

3) `ir.stage: "topic.preview" | "topic.work" | "extract.raw" | "extract.refined" | "extract.item_candidate"`
- 含义：漏斗阶段（不替代 `#card.type`，而是细分“处理进度”）
- 目标：让 UI 与调度知道“你在这张卡上做到哪一步”

4) `ir.lastAction: "preview" | "extract" | "refine" | "itemize" | "postpone" | "done"`
- 含义：最近一次动作类型（用于日志、调参与体验反馈）

说明：
- 现有 `ir.resumeBlockId` 建议保留，并在文档/管理面板中展示（可选）。
- `ir.position` 建议继续作为“队列优先级队列”的手动排序手柄（但与 `due` 分工明确：**due 决定是否进入今天，position 决定今天先做谁**）。

### 3.2 调度：引入“间隔增长”（A-Factor 思路的轻量版）

目标：Topic/Extract 都按“处理次数”自然拉长间隔，避免高优先级材料永远高频占用。

#### 3.2.1 初始间隔（首次进入系统）

建议：
- Topic：
  - `ir.intervalDays = 0`（当天可见）或 `1`（次日可见），由导入场景决定
  - `ir.stage = "topic.preview"`
- Extract：
  - `ir.intervalDays = 1~2`（趁热打铁）
  - `ir.stage = "extract.raw"`
  - `#card.priority` 继承父 Topic，但默认可“轻微上调”一档（可选策略）

#### 3.2.2 每次“已读/处理完成”后如何更新 interval

建议用一个简单公式（先可写死，后再配置化）：

- 设 `growthFactor`（增长因子）：
  - Topic：`1.25`（增长慢一点）
  - Extract：`1.35`（增长快一点，防止 Extract 长期占位）
- 更新：
  - `nextIntervalDays = clamp(min, max, max(1, intervalDays) * growthFactor)`
  - `nextDue = now + nextIntervalDays`

“推进漏斗”越明显，增长越快（可选增强）：
- `preview`：增长最小（只略推迟）
- `refine` / `itemize`：增长更大（你已经做了高价值工作）

#### 3.2.3 推后（Postpone）与自动后移（Auto-postpone）

建议把“跳过”改为“推后”，并且写回状态：

- 手动推后：设置 `due = now + postponeDays`，并 `postponeCount += 1`
- postponeDays 规则（可先硬编码三档）：
  - 高优先级：`1~2` 天
  - 中优先级：`3~5` 天
  - 低优先级：`7~14` 天
- 仍保留少量 jitter（抖动）避免堆积（例如 ±0.5 天），但不要完全随机到 10 天以上把材料“扔没了”。

自动后移（dailyLimit 溢出）建议改为：
- 只对溢出集合中的低优先级先动手（保留高优先级在今天）
- 推迟不是固定“明天 00:00”，而是按优先级档推迟到未来几天
- Topic 建议也写 `ir.due`（否则它永远“到期”，只是排在队尾，容易形成看不见的长期积压）

### 3.3 队列：明确 due 与 position 的分工（并修正 Extract 的有效优先级）

#### 3.3.1 规则（推荐）

1) 是否进入今天：看 `due`
- `dueDayStart <= todayStart` 才进入今天的候选池

2) 今天做谁先：看“有效优先级”
- Topic：以 `ir.position` 为第一排序键（手动优先队列），再以优先级/到期等做次级排序
- Extract：以 `#card.priority`（高/中/低）作为排序键（而不是 `ir.priority`）

#### 3.3.2 对当前实现的最小改动点

你不必推翻 `buildIRQueue`，可以按以下最小策略修复“Extract 排序失真”：

- 在收集 `IRCard` 时，把 Extract 的 `effectivePriority` 单独计算并放入 `IRCard`（例如 `effectivePriorityRank: 3|2|1`）。
- `sortExtracts` 改为按 `due`，再按 `effectivePriorityRank`。

### 3.4 漏斗推进：让 Extract 能“一键转 Item”

当前插件已有 SRS 的 Cloze/方向卡/列表卡等制卡能力（见 `src/srs/*Creator.ts`）。  
建议在 IR 会话里新增两类动作（至少做一个）：

1) `Extract → Cloze`（最常见）
- 在当前 Extract 块上执行创建 Cloze（复用 `src/srs/clozeUtils.ts` 的交互方式）
- 生成 SRS 卡后：
  - 方案 A（推荐默认）：对该 Extract 执行“读完”（移出 IR），保留正文作为上下文
  - 方案 B：保留 Extract 继续作为 IR（用于后续继续拆分）

2) `Extract → Q&A / Direction`
- 对“概念性解释/因果链/对照关系”更合适（避免硬挖空）

落地关键点：
- **只有**当“终身需要记住”且“已完全理解”才允许转 Item（UI 文案要强化这一点）。

## 4. 可执行落地清单（按 P0/P1/P2 分阶段）

### P0（立刻收益，改动可控）

- [x] 修正文档与实现不一致：`enableAutoExtractMark` 默认值/说明（已核对：当前默认关闭，文档与实现一致）
- [x] 把“跳过”改为“推后（Postpone）”，并写回 `ir.due`（`src/components/IncrementalReadingSessionDemo.tsx` + `src/srs/incrementalReadingStorage.ts` 新增 `postpone` API）
- [x] 统一优先级为 `ir.priority(0-100)` 单一真相，并同步到 `#card.priority(Number)`（展示/筛选用）
- [x] 逾期 Extract 优先进入 dailyLimit 队列，避免被 Topic 配额稀释
- [x] 溢出推后仅推迟低优先级优先（`src/srs/incrementalReadingCollector.ts#deferIROverflow` + `deferOverflowCards`）

### P1（让调度开始“学习”，解决 Topic 高频问题）

- [x] 引入 `ir.intervalDays` 并在 `markAsRead/markAsReadWithPriority/updatePriority` 中使用（`src/srs/incrementalReadingStorage.ts`）
- [x] Topic/Extract 的间隔按 readCount 逐步增长（轻量 A-Factor）
- [x] 溢出推后不再固定“明天 00:00”，而是按优先级推迟到未来几天

### P2（完成漏斗：Extract → Item 的闭环）

- [ ] （不做）IR 会话新增“一键转 Cloze/Q&A”动作（复用现有制卡逻辑）
- [x] 新增 `ir.stage` / `ir.lastAction`（用于会话提示、管理面板诊断）
- [x] 管理面板展示：priority、intervalDays、postponeCount、stage、lastAction（用于 backlog 治理）

## 5. 具体规则（可直接照做的默认参数建议）

> 这些参数先写死也可，跑通后再做成设置项。

### 5.1 优先级档（人类可理解）

建议仅作为心智模型（非代码分桶）：

- 80–100：高优先级（今天/明天必须推进）
- 40–79：中优先级（本周内推进）
- 0–39：低优先级（有空再看，可长期推后）

### 5.2 初始 intervalDays

由 `ir.priority` 与 cardType 计算基础间隔（见 `src/srs/incrementalReadingScheduler.ts`）

### 5.3 已读后的 interval 增长

- Topic：`intervalDays = max(1, intervalDays) * 1.25`
- Extract：`intervalDays = max(1, intervalDays) * 1.35`
- 上限建议：Topic 60 天；Extract 30 天（Extract 不该长期占 IR 系统）

### 5.4 推后（Postpone）天数

由 `ir.priority` 与 cardType 共同决定随机区间：

- Topic：约 1–14 天（优先级越低越长）
- Extract：约 1–10 天（优先级越低越长）

### 5.5 超额自动后移策略（dailyLimit 触发）

- 先保留高优先级（Topic/Extract）进入今天队列
- 其余按优先级从低到高推迟（写 `due`），并 `postponeCount += 1`

## 6. 每日 15–30 分钟流程示例（可直接执行）

> 目标不是“读完”，而是“推进漏斗”。

### Step 0：设定时间盒

- 15 分钟：只做 Extract（趁热打铁）
- 30 分钟：Topic + Extract + 1–3 张 Item 化

### Step 1：处理 Topic（粗读）

对每张 Topic（最多 2–5 张/天）：

1) 30–90 秒快速浏览
2) 立刻做一个动作：
   - 没价值：读完移出（Done）
   - 太难：推后（Postpone）
   - 有价值：做 1–3 个 Extract（只提最值钱的段落）
3) 不在 Topic 上精读到停不下来（时间盒优先）

### Step 2：处理 Extract（精炼）

对每张 Extract（最多 5–15 张/天，按时间盒缩放）：

1) 改写成更短、更清晰的句子（最小信息原则）
2) 如果仍然太长：拆成 2–3 个更小 Extract
3) 如果“终身需要记住且已理解”：
   - 转为 Cloze/Q&A（生成 SRS 卡）
   - 该 Extract 读完移出（或保留为上下文，视策略）
4) 不理解：不要硬记，直接推后或删除

### Step 3：收尾

- 时间到：剩余卡全部“推后”（不要跳过不留痕）
- 明确一个“下一步”：明天只处理高优先级 + 新 Extract

## 7. 实现指引（对照文件改哪里）

> 这里是“按文件定位”的落地导航，方便你直接开工。

- 状态字段与调度：`src/srs/incrementalReadingStorage.ts`
  - 新增 `intervalDays/postponeCount/stage/lastAction`（P1/P2）
  - 新增 `postpone(blockId, days)`（P0）
  - `markAsRead` 改为基于 `intervalDays` 计算 `due`（P1）

- 队列与自动后移：`src/srs/incrementalReadingCollector.ts`
  - `deferOverflowCards`：按 `ir.priority` 推后，并写回 `due/intervalDays/postponeCount`

- 会话 UI：`src/components/IncrementalReadingSessionDemo.tsx`
  - “跳过”→“推后”（P0）
  - 可选：显示 intervalDays/postponeCount/stage（P1/P2）
  - 可选：增加“转 Cloze/Q&A”（P2）

- 设置项：`src/srs/settings/incrementalReadingSettingsSchema.ts`
  - 把“时间盒/推后策略/每日新 Extract 限制”等做成设置（P1/P2）

- 文档同步：
  - 现有说明：`模块文档/渐进阅读.md`（建议补充 `ir.resumeBlockId`、修正默认值描述）
  - 本方案：`模块文档/渐进阅读_优化路线.md`（本文件）

## 8. 验收标准（判断优化是否有效）

- 高频 Topic 明显减少：同一 Topic 不会每天都出现（除非你主动设置为高优先级且确有推进）
- “跳过不留痕”消失：会话内每张卡都产生一次状态更新（至少 due 推后）
- Extract 不爆炸：管理面板中 Extract 的长期存量可控，且能逐步转化为 Item 或被清理
- 高优先级按时出现：即使 backlog 很大，高优先级材料仍能稳定出现在每天队列里
