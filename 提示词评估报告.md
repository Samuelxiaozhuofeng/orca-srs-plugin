# 提示词评估报告：通过标签自动识别记忆卡片

## 一、提示词分析

### ✅ 提示词中正确的部分

1. **功能需求清晰**：用户行为设计明确（父块=题目，子块=答案，标签=#card）
2. **API 选择正确**：
   - 使用 `get-blocks-with-tags` 获取带标签的块 ✓
   - 使用 `core.editor.setProperties` 设置属性 ✓
   - 直接修改 `_repr` 来设置块类型 ✓

3. **实现思路合理**：扫描 → 提取 → 标记的流程是正确的

### ⚠️ 需要优化的部分

#### 1. **标签识别方式需要明确**

**当前提示词的问题**：
- 提示词提到"从标签中解析出 deck 名称（例如标签 #deck/英语 ⇒ "英语"）"
- 但没有说明如何获取块的标签信息

**实际情况**：
- 在 Orca 中，标签不是直接存储在块的某个字段中
- 标签是通过 `block.refs` 数组中的引用实现的
- 标签引用的 `type` 为 `RefType.Property` (值为 2)
- 标签名称存储在 `BlockRef.alias` 字段中

**优化建议**：
```
在实现中，需要：
1. 遍历 block.refs 数组
2. 找到 type === RefType.Property 的引用（这些就是标签引用）
3. 从 ref.alias 中获取标签名称（例如 "card" 或 "deck/英语"）
4. 判断 alias === "card" 来识别卡片标签
5. 判断 alias.startsWith("deck/") 来解析 deck 名称
```

#### 2. **Deck 分组实现方式需要确认**

**当前提示词的问题**：
- 提示词提到"从标签中解析出 deck 名称"
- 但没有明确 deck 信息应该存储在哪里

**实际情况**：
- 可以在 `_repr` 中存储 `deck` 字段（推荐）
- 也可以在块属性中存储（使用 `core.editor.setProperties`）

**优化建议**：
```
建议将 deck 信息存储在 _repr 中，因为：
1. _repr 是块类型相关的数据，deck 属于卡片类型的一部分
2. 渲染器可以直接从 _repr 中读取 deck 信息
3. 与 front/back 的存储方式保持一致

示例：
block._repr = {
  type: "srs.card",
  front: "...",
  back: "...",
  deck: "英语"  // 从 #deck/英语 标签解析而来
}
```

#### 3. **API 调用细节需要补充**

**当前提示词的问题**：
- 提到"调用 Orca 的后端查询或标签 API"，但没有说明具体的调用方式

**实际情况**：
- `get-blocks-with-tags` 是通过 `orca.invokeBackend()` 调用的
- 参数是标签名称数组，返回的是块数组

**优化建议**：
```typescript
// 获取所有带 #card 标签的块
const taggedBlocks = await orca.invokeBackend("get-blocks-with-tags", ["card"])
```

#### 4. **属性设置方式需要明确**

**当前提示词的问题**：
- 提到"用 core.editor.setProperties 写入：srs.isCard, srs.due, srs.interval, srs.ease 等初始值"
- 但没有说明属性类型和初始值

**实际情况**：
- `setProperties` 需要指定属性类型（PropType）
- 需要明确每个属性的类型和初始值

**优化建议**：
```typescript
import { PropType } from "@/constants/db"  // 如果可用，否则使用数字

await orca.commands.invokeEditorCommand(
  "core.editor.setProperties",
  null,
  [blockId],
  [
    { name: "srs.isCard", value: true, type: PropType.Boolean },  // 或 4
    { name: "srs.due", value: new Date(), type: PropType.DateTime },  // 或 5
    { name: "srs.interval", value: 1, type: PropType.Number },  // 或 3
    { name: "srs.ease", value: 2.5, type: PropType.Number },  // 或 3
  ]
)
```

## 二、优化后的提示词建议

### 优化后的提示词（关键部分）

```
接下来，我们要实现「通过标签自动识别记忆卡片」。

用户行为设计如下：
- 用户写一个普通块：父块文本 = 题目，子块第 1 行 = 答案
- 父块上打标签 #card
- 可选：打标签 #deck/英语 来指定卡片分组（deck）

插件行为目标：
定期/按需扫描所有打了 #card 的块：
1. 把它们视为 SRS 卡片
2. 从父块文本中抽取 front
3. 从第一个子块（或子树）中抽取 back
4. 从标签中解析 deck 名称（例如标签 #deck/英语 ⇒ "英语"）
5. 给这些块设置合适的 _repr，让它们用 srs.card 渲染
6. 如有必要，给它们写入初始 SRS 属性

实现细节：

1. 触发时机：
   - 提供一个命令 srs.scanCardsFromTags，用户可以手动执行

2. 获取带标签的块：
   ```typescript
   const taggedBlocks = await orca.invokeBackend("get-blocks-with-tags", ["card"])
   ```

3. 对每个块进行处理：
   a. 读取父块内容作为 front：
      ```typescript
      const front = block.text || "（无题目）"
      ```
   
   b. 读取第一个子块内容作为 back：
      ```typescript
      let back = "（无答案）"
      if (block.children && block.children.length > 0) {
        const firstChildId = block.children[0]
        const firstChild = orca.state.blocks[firstChildId]
        if (firstChild && firstChild.text) {
          back = firstChild.text
        }
      }
      ```
   
   c. 从标签中解析 deck 名称：
      ```typescript
      // 遍历 block.refs，找到标签引用（type === RefType.Property，值为 2）
      let deckName: string | undefined = undefined
      for (const ref of block.refs) {
        if (ref.type === 2) {  // RefType.Property
          const tagAlias = ref.alias || ""
          // 检查是否是 deck 标签（格式：deck/名称）
          if (tagAlias.startsWith("deck/")) {
            deckName = tagAlias.substring(5)  // 提取 "deck/" 之后的部分
            break
          }
        }
      }
      ```
   
   d. 设置 _repr：
      ```typescript
      const blockWithRepr = block as BlockWithRepr
      blockWithRepr._repr = {
        type: "srs.card",
        front: front,
        back: back,
        ...(deckName && { deck: deckName })  // 如果有 deck，则添加
      }
      ```
   
   e. 设置初始 SRS 属性（可选）：
      ```typescript
      await orca.commands.invokeEditorCommand(
        "core.editor.setProperties",
        null,
        [block.id],
        [
          { name: "srs.isCard", value: true, type: 4 },  // PropType.Boolean
          { name: "srs.due", value: new Date(), type: 5 },  // PropType.DateTime
          { name: "srs.interval", value: 1, type: 3 },  // PropType.Number
          { name: "srs.ease", value: 2.5, type: 3 },  // PropType.Number
        ]
      )
      ```

4. 注意事项：
   - 标签信息存储在 block.refs 数组中，type === 2 的引用是标签引用
   - 标签名称在 ref.alias 字段中
   - 直接修改 block._repr 即可，Valtio 会自动触发响应式更新
   - 如果块已经有 _repr.type === "srs.card"，可以跳过或更新
```

## 三、代码实现建议

### 建议的文件结构

```
src/
  srs/
    scanFromTags.ts  // 扫描和标记功能
  main.ts  // 注册命令
```

### 关键实现点

1. **标签识别**：通过 `block.refs` 数组，查找 `type === 2` 的引用
2. **Deck 解析**：从 `ref.alias` 中检查 `deck/` 前缀
3. **块转换**：复用现有的 `makeCardFromBlock` 逻辑，但改为批量处理
4. **错误处理**：处理没有子块、标签格式错误等情况

## 四、总结

### 提示词优点
- ✅ 功能需求清晰
- ✅ API 选择基本正确
- ✅ 实现思路合理

### 需要优化的地方
- ⚠️ 需要明确标签的存储和访问方式（通过 refs 数组）
- ⚠️ 需要明确 deck 的存储位置（建议在 _repr 中）
- ⚠️ 需要补充 API 调用的具体代码示例
- ⚠️ 需要明确属性类型和初始值

### 建议
1. **使用优化后的提示词**：包含了更详细的实现细节
2. **先实现基础功能**：扫描 + 标记，deck 分组可以后续添加
3. **参考现有代码**：`makeCardFromBlock` 函数已经实现了单块转换，可以复用其逻辑
